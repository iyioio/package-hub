export interface PackageHubConfig {

    /**
     * Sets the current session name
     */
    session?:string;

    /**
     * Instructs the pkhub process to exit with the given code
     */
    exit?:number;

    /**
     * Enables verbose console output
     */
    verbose?:boolean;

    /**
     * Instructs pkhub to delete the npm cache of target projects when exiting
     */
    deleteCache?:boolean;

    /**
     * An array of config files that will only have their packages loaded. Loading a config file
     * as a hub allows you to reuse existing config files buy only load the packages they define.
     * this prevents un-needed targets and other configurations from being loaded.
     */
    hubs?:string[];

    /**
     * Defines a any array of targets. Do not use in combination with target. A target defines
     * an npm package that will be linked to loaded packages. Use the use property to define
     * the packages the target will be linked to.
     */
    targets?:string[];

    /**
     * Defines a single target. Do not use in combination with targets
     */
    target?:string;

    /**
     * An array of package names to be used by the targets of the config
     */
    use?:string[];

    /**
     * An array of script args to run after the args generated by the config
     */
    args?:string[];

    /**
     * An array of script args to run before the args generated by the config
     */
    preArgs?:string[];

    /**
     * An array of config files to load
     */
    include?:string[];

    /**
     * If true the targets and hubs of the config will be cleaned. If set to a value of 'all'
     * then all targets defined in the ~/.pkhub/db directory will be cleaned. When a target
     * is cleaned it is restored to its state before pkhub started. This is useful for cases
     * when pkhub is not shutdown gracefully and leaves behind temp files and dead package links
     */
    clean?:boolean|'all';

    /**
     * Causes execution to pause for the given number of milliseconds
     */
    sleep?:number;

    /**
     * An array of scoped configs that are loaded in their defined ordered. Scopes are useful for
     * when you want to load targets with different package usages.
     */
    scopes?:PackageHubConfig[];

    /**
     * Prints the current parsed arguments. When a config object is loaded it is converted into a 
     * series of arguments that at as a script. Using printArgs allows you to see how a given
     * config is converted into args.
     */
    printArgs?:boolean;

    /**
     * If true pkhub will only print information about what it intends to do for a given config
     */
    dryRun?:boolean;

    /**
     * Array of packages to run. Running packages will be available to targets to link to
     */
    packages?:PackageConfig[];
}

export interface PackageConfig
{
    /**
     * Name of the package. Will be inherited by the project's name in package.json if not defined
     */
    name?:string;

    /**
     * Tags that can be used to target the project
     */
    tags?:string[];

    /**
     * Path to a project directory or package.json
     */
    path:string;

    /**
     * Build directory relative to the project's root
     */
    outDir?:string;

    /**
     * Name of a npm script to run to run the package in watch mode. If false no watch script will
     * be ran. Default value = "watch". If no watch script is defined and the project contains
     * a tsconfig.json file and the tsconfig file defines an outDir then
     * "tsc --watch --outDir {tsconfig.outDir}" will be used.
     */
    watch?:string|false;
}

export interface ProjectTargetConfig
{
    /**
     * If true packages will be linked using symlinks
     */
    symlink?:boolean;

    /**
     * If true packages will be linked by coping the dist output from each package.
     * Default is true if symlink is false or undefined
     */
    copyDist?:boolean;
}

export interface ProjectTarget extends ProjectTargetConfig
{
    id:string;
    projectPath:string;
    nodeModulePath:string;
    nodeModuleBackupPath?:string;
    packageName:string;
}

export interface PackageInfo
{
    escapedName:string;
    lockPath:string;
    pkDbDir:string;
    lock:(work:()=>void)=>void;
    createDb:(addPackage?:ProjectTarget)=>void;
    cleanDb:(removePackage?:ProjectTarget,unlinkTargetPackage?:boolean)=>void;
    clearDb:()=>void;
    getTargets:()=>ProjectTarget[];
}
